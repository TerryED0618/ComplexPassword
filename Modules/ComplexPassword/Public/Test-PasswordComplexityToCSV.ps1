Function Test-PasswordComplexityToCSV {
	<#
		.SYNOPSIS
			Test password complexity from a CSV file.

		.DESCRIPTION
			Test password complexity from a CSV file.

			For Windows's default domain password policy with complexity enabled use the following parameters: -MinLength 6 -MinCategory 3

			WARNING: This tools reads into memory, passwords in clear text, which could be exposed if the executing workstation is compromised.

		.INPUTS
			The default input file name is the <name of this script>.CSV.  This can be overridden with the -Path parameter.

			The input CSV file requires the column header 'Password' (column order insensitive, case insensitive), and optionally 'UserName' and 'DisplayNamew' columns.  All other columns are ignored but passed through to the output file.

			The UserName value, if present and over 3 characters in length, is tested to not be contained within the password value.

			The DisplayName value, if present, is parsed and tested that no components over 3 characters in length are contained within the password value. DisplayName is parsed by the following characters:
				tabs '`t'
				space ' '
				number or pound sign '#'
				comma ','
				minus sign, dash or hyphen '-'
				period '.'
				underscore '_'

		.OUTPUTS
			One output file is generated by default in a subfolder called '.\Reports\'.  The output file name is in the format of: <date/time/timezone stamp>-<msExchOrganizationContainer>-<ScriptName>.CSV.
			If parameter -Debug or -Verbose is specified, then a second file, a PowerShell transcript (*.TXT), is created with the same name and in the same location.

			The input file is read, two additional columns are added 'IsCompliant' and 'Status', and then written to the output file.  IsCompliant has a TRUE or FALSE value.  Status is either empty, or has a combined list of all non-compliance.

		.PARAMETER MinLength Int
			The minimum password character length required to be compliant.  The default is zero.

		.PARAMETER MinUppercase Int
			The minimum number of upppercase letters required to be compliant.  The default is zero.

		.PARAMETER MinLowercase Int
			The minimum number of lowercase letters required to be compliant.  The default is zero.

		.PARAMETER MinNumber Int
			The minimum number of number characters required to be compliant.  The default is zero.

		.PARAMETER MinSpecial Int
			The minimum number of special characters required to be compliant.  The default is zero.

		.PARAMETER MinOther Int
			The minimum number of Unicode characters required to be compliant.  The default is zero.  Any Unicode character that is categorized as an alphabetic character but is not uppercase or lowercase. This includes Unicode characters from Asian languages.

		.PARAMETER MinCategory Int
			The minimum number of character categories (upper/lower/number/special) required to be compliant.  The maxiumum value is 5.  The default is zero.

		.PARAMETER UseActiveDirectory Switch
			Default is not to use Active Directory.  If enabled:
			* Uses executing workstation's Active Directory domain
			* Gets the default domain password policy
			* Overwrites -MinLength and -MinCategory if either are weaker
			* Reads InFile's UserName column (can have DistinguishedName, GUID, SID, or SamAccountName values)
			* Gets the user properties SamAccountName and DisplayName from Active Directory, using them instead of the InFile's columns UserName and DisplayName values.
			
			No attempt to validate the password against Active Directory objects is made.
			
			
		.PARAMETER Delimiter Char
			Specifies the delimiter that separates the property values in the CSV file. The default is a comma (,). Enter a character, such as a colon (:). To specify a semicolon (;), enclose it in quotation marks.

			If you specify a character other than the actual string delimiter in the file, Import-Csv cannot create objects from the CSV strings. Instead, it returns the strings.

		.PARAMETER Encoding String
			Specifies the type of character encoding that was used in the CSV file. Valid values are Unicode, UTF7, UTF8, ASCII, UTF32, BigEndianUnicode, Default, and OEM. The default is ASCII.

			This parameter is introduced in Windows PowerShell 3.0.

		.PARAMETER Header String[]
			Specifies an alternate column header row for the imported file. The column header determines the names of the properties of the object that Import-Csv creates.

			Enter a comma-separated list of the column headers. Enclose each item in quotation marks (single or double). Do not enclose the header string in quotation marks. If you enter fewer column headers than there are columns, the remaining columns will have no header. If you enter more headers than there are columns, the extra headers are ignored.

			When using the Header parameter, delete the original header row from the CSV file. Otherwise, Import-Csv creates an extra object from the items in the header row.

		.PARAMETER Path String[]
			Specifies the path to the CSV file to import. You can also pipe a path to Import-Csv.

		.PARAMETER UseCulture SwitchParameter
			Use the list separator for the current culture as the item delimiter. The default is a comma (,).

			To find the list separator for a culture, use the following command: (Get-Culture).TextInfo.ListSeparator. If you specify a character other than the delimiter used in the CSV strings, ConvertFrom-CSV cannot create objects from the CSV strings. Instead, it returns the strings.

		.PARAMETER LiteralPath String[]
			Specifies the path to the CSV file to import. Unlike Path, the value of the LiteralPath parameter is used exactly as it is typed. No characters are interpreted as wildcards. If the path includes escape characters, enclose it in single quotation marks. Single quotation marks tell Windows PowerShell not to interpret any characters as escape sequences.

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -OutFileNameTag Default

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -MinLength 6 -MinCategory 3 -OutFileNameTag Len6Cat3

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -MinLength 15 -OutFileNameTag Len15

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -MinCategory 5 -OutFileNameTag Cat5

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -MinUppercase 1 -MinLowercase 1 -MinNumber 1 -MinSpecial 1 -MinOther 1 -OutFileNameTag u1L1N1S1o1

		.EXAMPLE
			Test-PasswordComplexityFromCSV -Path .\Test-PasswordComplexityFromCSV-TEST.csv -ExcludeCharacter '~,' -OutFileNameTag XC

		.NOTE
			Author: Terry E Dow
			Creation Date: 2018-08-01

			Reference:
				Password must meet complexity requirements https://docs.microsoft.com/en-us/windows/security/threat-protection/security-policy-settings/password-must-meet-complexity-requirements
				Selecting Secure Passwords https://msdn.microsoft.com/en-us/library/cc875839.aspx?f=255&MSPPError=-2147217396
				Character Classes in Regular Expressions https://docs.microsoft.com/en-us/dotnet/standard/base-types/character-classes-in-regular-expressions#SupportedUnicodeGeneralCategories
				Unicode Regular Expressions http://www.unicode.org/reports/tr18/
				Unicode Regular Expressions https://www.regular-expressions.info/unicode.html#prop
				Unicode Characters in the 'Letter, Other' Category http://www.fileformat.info/info/unicode/category/Lo/list.htm
	#>
	[CmdletBinding(
		SupportsShouldProcess = $TRUE # Enable support for -WhatIf by invoked destructive cmdlets.
	)]
	#[System.Diagnostics.DebuggerHidden()]
	Param(

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinLength = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinUppercase = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinLowercase = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinNumber = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinSpecial = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Int] $MinOther = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[ValidateRange(0,5)]
		[Int] $MinCategory = 0,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Switch] $UseActiveDirectory = $NULL,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[String] $ExcludeCharacter = '',


		[Parameter(
		ValueFromPipeline=$TRUE,
		Position=2)]
		[Char] $Delimiter = $NULL,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[String] $Encoding = $NULL,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[String[]] $Header = $NULL,

		[Parameter(
		ValueFromPipeline=$TRUE,
		Position=1)]
		[String[]] $Path = '.\Test-PasswordComplexityFromCSV.csv',

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[Switch] $UseCulture = $NULL,

		[Parameter(
		ValueFromPipeline=$TRUE,
		ValueFromPipelineByPropertyName=$TRUE )]
		[String[]] $LiteralPath = $NULL,

	#region Script Header

		[Parameter( HelpMessage='Specify the script''s execution environment source.  Must be either ''ComputerName'', ''DomainName'', ''msExchOrganizationName'' or an arbitrary string. Defaults is msExchOrganizationName.' ) ]
			[String] $ExecutionSource = $NULL,

		[Parameter( HelpMessage='Optional string added to the end of the output file name.' ) ]
			[String] $OutFileNameTag = $NULL,

		[Parameter( HelpMessage='Specify where to write the output file.' ) ]
			[String] $OutFolderPath = '.\Reports',

		[Parameter( HelpMessage='When enabled, only unhealthy items are reported.' ) ]
			[Switch] $AlertOnly = $FALSE,

		[Parameter( HelpMessage='Optionally specify the address from which the mail is sent.' ) ]
			[String] $MailFrom = $NULL,

		[Parameter( HelpMessage='Optioanlly specify the addresses to which the mail is sent.' ) ]
			[String[]] $MailTo = $NULL,

		[Parameter( HelpMessage='Optionally specify the name of the SMTP server that sends the mail message.' ) ]
			[String] $MailServer = $NULL,

		[Parameter( HelpMessage='If the mail message attachment is over this size compress (zip) it.' ) ]
			[Int] $CompressAttachmentLargerThan = 5MB
	)

	#Requires -version 3
	Set-StrictMode -Version Latest

	# Detect cmdlet common parameters.
	$cmdletBoundParameters = $PSCmdlet.MyInvocation.BoundParameters
	$Debug = If ( $cmdletBoundParameters.ContainsKey('Debug') ) { $cmdletBoundParameters['Debug'] } Else { $FALSE }
	# Replace default -Debug preference from 'Inquire' to 'Continue'.
	If ( $DebugPreference -Eq 'Inquire' ) { $DebugPreference = 'Continue' }
	$Verbose = If ( $cmdletBoundParameters.ContainsKey('Verbose') ) { $cmdletBoundParameters['Verbose'] } Else { $FALSE }
	$WhatIf = If ( $cmdletBoundParameters.ContainsKey('WhatIf') ) { $cmdletBoundParameters['WhatIf'] } Else { $FALSE }
	Remove-Variable -Name cmdletBoundParameters -WhatIf:$FALSE

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Collect script execution metrics.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	$scriptStartTime = Get-Date
	Write-Verbose "`$scriptStartTime:,$($scriptStartTime.ToString('s'))"

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Include external functions.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	#. .\New-OutFilePathBase.ps1

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Define internal functions.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8


	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Build output and log file path name.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	$outFilePathBase = New-OutFilePathBase -OutFolderPath $OutFolderPath -ExecutionSource $ExecutionSource -OutFileNameTag $OutFileNameTag

	$outFilePathName = "$($outFilePathBase.Value).csv"
	Write-Debug "`$outFilePathName: $outFilePathName"
	$logFilePathName = "$($outFilePathBase.Value).log"
	Write-Debug "`$logFilePathName: $logFilePathName"

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Optionally start or restart PowerShell transcript.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	If ( $Debug -Or $Verbose ) {
		Try {
			Start-Transcript -Path $logFilePathName -WhatIf:$FALSE
		} Catch {
			Stop-Transcript
			Start-Transcript -Path $logFilePathName -WhatIf:$FALSE
		}
	}

	#endregion Script Header

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Collect report information
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	# Validate parameters
	$hasUnicode = $FALSE
	If ( $MinOther ) { $hasUnicode = $TRUE }
	If ( 5 -EQ $MinCategory ) { $hasUnicode = $TRUE }

	# Create a hash table to splat Import-CSV parameters.
	$importCsvParameters = @{}
	If ( $Delimiter ) { $importCsvParameters.Delimiter = $Delimiter }
	If ( $Encoding ) { $importCsvParameters.Encoding = $Encoding }
	If ( $Header ) { $importCsvParameters.Header = $Header }
	If ( $Path ) { $importCsvParameters.Path = $Path }
	If ( $UseCulture ) { $importCsvParameters.UseCulture = $UseCulture }
	If ( $LiteralPath ) { $importCsvParameters.LiteralPath = $LiteralPath }
	If ( $Debug ) {
		ForEach ( $key In $importCsvParameters.Keys ) {
			Write-Debug "`$importCsvParameters[$key]`:,$($importCsvParameters[$key])"
		}
	}

	# Create a hash table to splat Export-CSV parameters.
	$exportCsvParameters = @{}
	$exportCsvParameters.Path = $outFilePathName
	$exportCsvParameters.NoTypeInformation = $TRUE
	$exportCsvParameters.WhatIf = $FALSE
	If ( $hasUnicode ) {
		$exportCsvParameters.Encoding = 'UTF8'
	} Else {
		$exportCsvParameters.Encoding = 'ASCII'
	}
	If ( $Debug ) {
		ForEach ( $key In $exportCsvParameters.Keys ) {
			Write-Debug "`$exportCsvParameters[$key]`:,$($exportCsvParameters[$key])"
		}
	}

	# Import InFile file.
	Import-Csv @importCsvParameters |
		ForEach-Object {

			$userName = ''
			# Try to get user properties from InFile.
			Try {
				$userName = $PSItem.UserName
			} Catch {
			}
		
			# Try to get user properties from InFile.
			$displayName = ''
			Try {
				$displayName = $PSItem.DisplayName
			} Catch {
			}
				
			# Create a hash table to splat Test-PasswordComplexity parameters.
			$testPasswordComplexityParameters = @{}
			$testPasswordComplexityParameters.Password = $PSItem.Password
			If ( $userName ) { $testPasswordComplexityParameters.UserName = $userName }
			If ( $displayName ) { $testPasswordComplexityParameters.DisplayName = $displayName }
			If ( $MinLength ) { $testPasswordComplexityParameters.MinLength = $MinLength }
			If ( $MaxLength ) { $testPasswordComplexityParameters.MaxLength = $MaxLength }
			If ( $MinUppercase ) { $testPasswordComplexityParameters.MinUppercase = $MinUppercase }
			If ( $MinLowercase ) { $testPasswordComplexityParameters.MinLowercase = $MinLowercase }
			If ( $MinNumber ) { $testPasswordComplexityParameters.MinNumber = $MinNumber }
			If ( $MinSpecial ) { $testPasswordComplexityParameters.MinSpecial = $MinSpecial }
			If ( $MinOther ) { $testPasswordComplexityParameters.MinOther = $MinOther }
			If ( $MinCategory ) { $testPasswordComplexityParameters.MinCategory = $MinCategory }
			If ( $UseActiveDirectory ) { $testPasswordComplexityParameters.UseActiveDirectory = $UseActiveDirectory }
			If ( $ExcludeCharacter ) { $testPasswordComplexityParameters.ExcludeCharacter = $ExcludeCharacter }
			If ( $Debug ) {
				ForEach ( $key In $testPasswordComplexityParameters.Keys ) {
					Write-Debug "`$testPasswordComplexityParameters[$key]`:,$($testPasswordComplexityParameters[$key])"
				}
			}
			$testResult = Test-PasswordComplexity @testPasswordComplexityParameters
				
			# Write metrics.
			Write-Output ( $PSItem | Select-Object -Property *,@{ Name='IsCompliant'; Expression={ $testResult.isCompliant } },@{ Name='Status'; Expression={ $testResult.status } } )

		} |
		Export-CSV @exportCsvParameters

	#region Script Footer

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Optionally mail report.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	If ( (Test-Path -PathType Leaf -Path $outFilePathName) -And $MailFrom -And $MailTo -And $MailServer ) {

		# Determine subject line report/alert mode.
		If ( $AlertOnly ) {
			$reportType = 'Alert'
		} Else {
			$reportType = 'Report'
		}

		$messageSubject = "Test Password Complexity $reportType for $($outFilePathBase.ExecutionSourceName) on $((Get-Date).ToString('s'))"

		# If the out file is larger then a specified limit (message size limit), then create a compressed (zipped) copy.
		Write-Debug "$outFilePathName.Length:,$((Get-ChildItem -LiteralPath $outFilePathName).Length)"
		If ( $CompressAttachmentLargerThan -LT (Get-ChildItem -LiteralPath $outFilePathName).Length ) {

			$outZipFilePathName = "$outFilePathName.zip"
			Write-Debug "`$outZipFilePathName:,$outZipFilePathName"

			# Create a temporary empty zip file.
			Set-Content -Path $outZipFilePathName -Value ( "PK" + [Char]5 + [Char]6 + ("$([Char]0)" * 18) ) -Force -WhatIf:$FALSE

			# Wait for the zip file to appear in the parent folder.
			While ( -Not (Test-Path -PathType Leaf -Path $outZipFilePathName) ) {
				Write-Debug "Waiting for:,$outZipFilePathName"
				Start-Sleep -Milliseconds 20
			}

			# Wait for the zip file to be written by detecting that the file size is not zero.
			While ( -Not (Get-ChildItem -LiteralPath $outZipFilePathName).Length ) {
				Write-Debug "Waiting for ($outZipFilePathName\$($outFilePathBase.FileName).csv).Length:,$((Get-ChildItem -LiteralPath $outZipFilePathName).Length)"
				Start-Sleep -Milliseconds 20
			}

			# Bind to the zip file as a folder.
			$outZipFile = (New-Object -ComObject Shell.Application).NameSpace( $outZipFilePathName )

			# Copy out file into Zip file.
			$outZipFile.CopyHere( $outFilePathName )

			# Wait for the compressed file to be appear in the zip file.
			While ( -Not $outZipFile.ParseName("$($outFilePathBase.FileName).csv") ) {
				Write-Debug "Waiting for:,$outZipFilePathName\$($outFilePathBase.FileName).csv"
				Start-Sleep -Milliseconds 20
			}

			# Wait for the compressed file to be written into the zip file by detecting that the file size is not zero.
			While ( -Not ($outZipFile.ParseName("$($outFilePathBase.FileName).csv")).Size ) {
				Write-Debug "Waiting for ($outZipFilePathName\$($outFilePathBase.FileName).csv).Size:,$($($outZipFile.ParseName($($outFilePathBase.FileName).csv)).Size)"
				Start-Sleep -Milliseconds 20
			}

			# Send the report.
			Send-MailMessage `
				-From $MailFrom `
				-To $MailTo `
				-SmtpServer $MailServer `
				-Subject $messageSubject `
				-Body 'See attached zipped Excel (CSV) spreadsheet.' `
				-Attachments $outZipFilePathName

			# Remove the temporary zip file.
			Remove-Item -LiteralPath $outZipFilePathName

		} Else {

			# Send the report.
			Send-MailMessage `
				-From $MailFrom `
				-To $MailTo `
				-SmtpServer $MailServer `
				-Subject $messageSubject `
				-Body 'See attached Excel (CSV) spreadsheet.' `
				-Attachments $outFilePathName
		}
	}

	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8
	# Optionally write script execution metrics and stop the Powershell transcript.
	#---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8

	$scriptEndTime = Get-Date
	Write-Verbose "`$scriptEndTime:,$($scriptEndTime.ToString('s'))"
	$scriptElapsedTime =  $scriptEndTime - $scriptStartTime
	Write-Verbose "`$scriptElapsedTime:,$scriptElapsedTime"
	If ( $Debug -Or $Verbose ) {
		Stop-Transcript
	}
	#endregion Script Footer
}
